#nullable enable
override SimpleExec.ExitCodeException.Message.get -> string!
override SimpleExec.ExitCodeReadException.Message.get -> string!
SimpleExec.Command
SimpleExec.ExitCodeException
SimpleExec.ExitCodeException.ExitCode.get -> int
SimpleExec.ExitCodeException.ExitCodeException(int exitCode) -> void
SimpleExec.ExitCodeReadException
SimpleExec.ExitCodeReadException.ExitCodeReadException(int exitCode, string! standardOutput, string! standardError) -> void
SimpleExec.ExitCodeReadException.StandardError.get -> string!
SimpleExec.ExitCodeReadException.StandardOutput.get -> string!
static SimpleExec.Command.ReadAsync(string! name, string! args = "", string! workingDirectory = "", System.Action<System.Collections.Generic.IDictionary<string!, string?>!>? configureEnvironment = null, System.Text.Encoding? encoding = null, System.Func<int, bool>? handleExitCode = null, string? standardInput = null, bool cancellationIgnoresProcessTree = false, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<(string! StandardOutput, string! StandardError)>!
static SimpleExec.Command.ReadAsync(string! name, System.Collections.Generic.IEnumerable<string!>! args, string! workingDirectory = "", System.Action<System.Collections.Generic.IDictionary<string!, string?>!>? configureEnvironment = null, System.Text.Encoding? encoding = null, System.Func<int, bool>? handleExitCode = null, string? standardInput = null, bool cancellationIgnoresProcessTree = false, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task<(string! StandardOutput, string! StandardError)>!
static SimpleExec.Command.Run(string! name, string! args = "", string! workingDirectory = "", bool noEcho = false, string? echoPrefix = null, System.Action<System.Collections.Generic.IDictionary<string!, string?>!>? configureEnvironment = null, bool createNoWindow = false, System.Func<int, bool>? handleExitCode = null, bool cancellationIgnoresProcessTree = false, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
static SimpleExec.Command.Run(string! name, System.Collections.Generic.IEnumerable<string!>! args, string! workingDirectory = "", bool noEcho = false, string? echoPrefix = null, System.Action<System.Collections.Generic.IDictionary<string!, string?>!>? configureEnvironment = null, bool createNoWindow = false, System.Func<int, bool>? handleExitCode = null, bool cancellationIgnoresProcessTree = false, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> void
static SimpleExec.Command.RunAsync(string! name, string! args = "", string! workingDirectory = "", bool noEcho = false, string? echoPrefix = null, System.Action<System.Collections.Generic.IDictionary<string!, string?>!>? configureEnvironment = null, bool createNoWindow = false, System.Func<int, bool>? handleExitCode = null, bool cancellationIgnoresProcessTree = false, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!
static SimpleExec.Command.RunAsync(string! name, System.Collections.Generic.IEnumerable<string!>! args, string! workingDirectory = "", bool noEcho = false, string? echoPrefix = null, System.Action<System.Collections.Generic.IDictionary<string!, string?>!>? configureEnvironment = null, bool createNoWindow = false, System.Func<int, bool>? handleExitCode = null, bool cancellationIgnoresProcessTree = false, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.Task!
